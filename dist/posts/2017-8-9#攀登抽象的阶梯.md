---
Title: 攀登抽象的阶梯
PublishDate: 2017/8/9 23:00:41
Tags: 编码 | 哲思
---

![](http://imglf1.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDVnhjaUsxSTloMW9ObXdwTHJ5RkJaZ2VuVUtVUUZJaVlnPT0.jpeg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)
常见的三种编程范式
1. 命令式(过程式)
2. 函数式
3. 对象式

命令式与函数式编程的主要区别体现在对过程提供的抽象能力上，在lisp中赋予了过程第一级权利:  
1. 可以将过程命名  
2. 可以提供给其它过程作为参数或作为返回结果
3. 可以包含在数据结构中  

第二点实现的代价就意味着将过程作为值返回，需要为过程中的变量提供存储环境，无论其是否被调用，如果采用词法作用域，那这就是闭包，在典型的命令式编程语言中，例如C语言，我们或许可以通过某些方式实现第一级权利，比如传递指针。  

但是，两种编程范式的差异不仅体现在这一方面，还有对待副作用的态度，也就是赋值。
在函数式编程中，函数的概念更贴近数学中映射的概念，输入参数，输出结果，简单的映射，将输入集映射到结果集，过程执行中不改变外部环境的状态，也不依赖外部环境的状态。由此引入了更多源自数学的概念，如高阶函数，偏函数，柯里化，函数组合等。  

在命令式编程的典型C语言中，同样提供了对过程的抽象能力，即将过程抽象为函数，但是此函数就并非函数式编程语言里的函数了，最显然的是没有第一级特权。我们在命令式编程语言中所用到的最重要的特性与思想是变量这一概念，而非函数。  
这一概念源于计算机科学家对计算本质的两种不同观念。对于变量，其背后体现的是图灵机的思想，变量对应着图灵机上的格子，内存里的存储空间，用于存储各种状态，我们用命令式编程就意味着操作各种状态，通过状态的变迁模拟计算的过程，这就是命令式编程的观念。  
而函数式编程却源自另外一种计算模型，一种更抽象更数学的模型，即lambda演算，在这个世界里没有存储变量的格子，有的只是三条简单的规则：  
1. α变换
2. β规约
3. η变换

这像是某种形式化的数学字符串游戏，倒不像一台可以造出来的计算“机”。当然，这两模型的能力却是等价的，所以对于工程师而言当然更倾向于图灵机的描述了。在函数式编程里，我们做出各种过程抽象，组合它们进而构建更高阶的抽象，将数据塞进这些抽象的过程中进行着各种变换，最终得到一个输出，在LISP语言中更是存在更加魔幻般的抽象形式，数据和代码于LISP中用的是同一种结构描述，这种特性被称之为同像性，在这里，数据和可执行代码的界限变得模糊，因此产生了宏这一可怕的抽象能力，运行的代码可以被当做数据一样修改操作，然后再执行。  

函数式编程就是这样，识别程序里的基本抽象，组合出更复杂的抽象，进而构造出威力更加强大更高阶的抽象，连接这些抽象，就像构造一个有机的生命体一般，但是，在这个过程中也应当控制好抽象的层次，我们用抽象来控制着程序的日益庞大所产生的复杂度，这某种程度上也在侧面诠释了程序构造的本质，即控制复杂度，提供抽象能力是任何程序语言的基本元素，各语言的差异只在于对这种能力提供的多少或强弱，强大的抽象能力同时也带来了各种约束，这也是各编程语言的取舍点。  
当然，除了以上两种典型的编程范式外，还存在其它几种编程范式，比如最流行的OOP面向对象编程，但是无论何种范式，在用于模拟真实世界而言都是不够的，或多或少会存在那么点麻烦或不自在，因此，无论如何不要手头有锤子就把一切当做钉子，要知道手里的模型是不可能适应任何场景的，它们存在应用范围，只对某一类问题是最优解，而不是全部问题。因此，我们要让模型去适应世界，而不是让世界适应你的模型，对于后者，这显然是做不到，不可能的！
