---
Title: 又一篇什么是Monad.md
Date: 2017/9/1 21:48:38
Tags: 编码
---

一开始抱着猎奇的心态学习各种编程语言，从汇编、C/C++、Python、直到LISP和haskell，直到工作后才幡然醒悟，学这么多编程语言而不去使用，那无异于“以有涯随无涯”，回首才发现遗忘是多么可怕的事情，以前用C语言刷OJ题目，现在不看文档怕是连掌握C语言都不敢说，以前学王爽的《汇编语言》对照于渊的《一个操作系统的实现》写操作系统内核启动器，现在怕是对汇编也只敢说了解一点点，所以，学以致用很重要。  
当然，并不能因为遗忘而否定学习的意义，学习的意义反而正是那些遗忘之后留下的东西，学过这么多语言，了解了这么多编程范式，学起新的语言来也确实颇有一番一通百通的感觉，拿起文档就写，新语言的特性也能很快上手。真正停止追逐语言的脚步，是从SICP开始的，翻开这本书的时候仿佛受到了启示一般，学语言这么久，感触最深的一点，那就是对于学习者而言，我们需要的不是一本规范，也不是一本操作手册，而是一本解释，SCIP正好回答了我的疑惑，正如其书名所言，说的是计算机程序的构造与解释，理解到编程活动的本质是通过抽象的手段控制复杂度这样道理后，对语言的追求的执念也就放下了，便开始放弃追求语言，转而关注各类语言中所提供的“抽象方式”，对某门语言的学习，仅仅是学习如何在其中恰当的表达思想，不再去死扣规范和各种细节，当然，如果这门语言是工作用的，那才值得去这样做。

当见识到抽象的力量之后就一发不可收拾了，在函数式编程里充斥着各种“黑魔法”，而我自己工作用的JS语言恰好具备展示这些“黑魔法”的能力，尽管有些蹩脚，但也并非不能用，平日里经常用JS写一些函数式的代码，作为一个“魔法师”，我总会对自己的能力和知识感到不满，便求精进，然后就理所当然的掉进了函数式的坑里，撞死在范畴论和Monad面前。

不管怎样，如果学过一样东西不能用自己的语言表达出来的话，那就和学一样，最终总会被遗忘的。所以我就要来讲一讲Monad！关于这个Monad有一句著名的话：
> 一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已，有什么难以理解的。

emmmm，确实不难理解，当然，首先你要能理解上面那句话里谈到的名词，什么是函子，什么是范畴，什么自函子，什么是自函子范畴，什么是幺半群，要理解这些你首先就要面对范畴论，然后你一看范畴论就会犯愁。所以直接从数学书起手而不借助例子肯定死的很惨，我当然也不是这么理解的。我对于Monad的学习来自于这里，[《JS 函数式编程指南》](https://github.com/llh911001/mostly-adequate-guide-chinese)，关于函数式编程的种种好处和例子我就不说了。

借住编程例子来解释范畴论的概念是很直观的，我先丢概念，不要慌，稍后就解释这些概念如何跟实际编程对应起来的。

## 范畴论
范畴论又称猫论（category theory）是数学中的一个抽象分支，能够形式化诸如集合论（set theory）、类型论（type theory）、群论（group theory）以及逻辑学（logic）等数学分支中的一些概念。范畴学主要处理对象（object）、态射（morphism）和变化式（transformation），**而这些概念跟编程的联系非常紧密**。

### 什么是范畴？
> "范畴就是使用箭头连接的物体。"（In mathematics, a category is an algebraic structure that comprises "objects" that are linked by "arrows". ）

![范畴](\posts\assets\category.png)  
这里的物体不是单个的对象，而是所指有这些箭头连接起来的对象的集合，也就是上图中圆圈包裹的整体，当然，除此之外还有一些约束，后面再解释它跟编程中概念的关系，它的形式化定义是这样的：

![范畴](\posts\assets\category2.png)  
1. 一系列的对象(object)；
2. 一系列的态射(morphism)；
3. 一个组合(composition)操作符，用点(.)表示，用于将态射进行组合；

然后在此之上还需要满足如下约束，
1. 态射组合要满足结合律，即(f.g).h = f.(g.h)；
2. 态射在这个结构中要是封闭的，也就是，如果存在态射f：A->B, g：B->C，则必然存在唯一态射h = f.g，使得h：A->C；
3. 对结构中的每一个对象 A, 必须存在一个单位态射 Id: A -> A， 对于单位态射，显然，对任意其它态射 f, f.I = f;

现在，让我们开始把数学概念迁移类比到编程中的概念上，对于范畴定义中的对象，我们类比于编程中的类型，态射类比成函数，因此很自然的，我们编写函数实际就是实现一个态射，将输入形参的类型映射到返回形参的类型，如果是无副作用的纯函数，结合律也是很显然的，剩下的疑问就是，函数是多参数的咋整啊？那就Curry化啊，这样就满足范畴定义的形式了。剩下的单位态射起手就能写一个，这样概念对应起来了之后，我们的就可以在数学模型的约束和指导下来玩一些“黑魔法”。

上码：
```javascript
// 态射组合
var compose = function(f,g) {
  return function(x) {
    return f(g(x));
  };
// 单位态射
var identity = function(x) {
  return x;
}
// 结合律
var associative = compose(f, compose(g, h)) == compose(compose(f, g), h);
};
```

通过类型和函数我们可以构造出一个范畴来，在这个范畴里，对象就是类型，函数就是态射，我们也构造了单位态射和组合操作，并验证了其满足结合律。对于范畴可能应用最多的就是组合与结合律，这可能给人感触不深，形象比喻的话，这可能就像构造管道，告诉你管道与管道是可以组合的（态射组合），管道的组合是符合结合律的，函数式编程就像往管道一端塞入一朵玫瑰然后流出一只兔子，即便如此简单的观念也足以改变编程的思路，让我们从命令式编程转换到声明式编程，即通过管道把数据在一系列纯函数间传递的程序。在此之上进一步抽象的话，我们就能构造出威力更加强大的函子(functor)。

### 什么是函子
令C和D是两个范畴。一个从C到D函子F由如下信息给出：

1. 每个C中的对象 X 对应 D 中的一个对象 F(X)；
2. 每个C中的态射  f: X -> Y 对应 D 中的一个态射 F(f): F(X) -> F(Y) 使得如下两个条件成立：
（1）F把恒等态射变为恒等态射，即 F(idX) = idF(X);
（2）F保持态射的复合，即  F(g.f) = F(g).F(f)；

在范畴论中，函子(functor) 接受一个范畴的对象和态射（morphism），然后把它们映射（map）到另一个范畴里去。根据定义，这个新范畴一定会有一个单位元（identity），也一定能够组合态射，可以把范畴想象成一个有着多个对象的网络，对象之间靠态射连接。那么 functor 可以把一个范畴映射到另外一个，而且不会破坏原有的网络。函子在代码中的实现方式是用 map 包裹每一个函数，用 functor 包裹每一个类型，这样就能保证每个普通的类型和函数都能在新环境下继续使用组合。
假设我们有两个范畴C，D，函子就是一个能把C范畴中任意对象Ca映射成Da的态射，而且保持映射后其原有结构不变，依旧满足关于范畴的相关定律。  
另外一点，函子在态射组合上必须满足分配律，也就是说：F(f o g) = F(f) o F(g)

![范畴](\posts\assets\category3.png)
![范畴](\posts\assets\category4.png)  

直接来一个Maybe函子来介绍这种范畴映射带来的好处吧，下面代码只是函子概念在代码中的表达，为了描述这种映射，一般会将函子形象比喻成容器盒子之类的东西，但切记函子只不过是范畴间的映射而已。

```javascript
// 构造一个函子对象，一般会形象比喻为构造容器
var Maybe = function(x) {
  this.__value = x;
}
// 1. 每个C中的对象 X 对应 D 中的一个对象 F(X)；
Maybe.of = function(x) {
  return new Maybe(x);
}
Maybe.prototype.isNothing = function() {
  return (this.__value === null || this.__value === undefined);
}
// 每个C中的态射  f: X -> Y 对应 D 中的一个态射 F(f): F(X) -> F(Y)
// 恒等态射映射和态射复合保持自行验证
Maybe.prototype.map = function(f) {
  return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));
}

```
![范畴](\posts\assets\functormap.png)

我们把一个东西丢给Maybe函子之后，就将原对象从其所在的范畴提升到了Maybe函子组成范畴中去，在这个范畴里的元素，所有态射（map）操作都会自动进行空值检测。无法体会这种抽象提升带来的好处？简单来讲，我们把低层次抽象中不方便处理，不能处理的一些玩意（状态，副作用，IO等）经过函子进行抽象提升到了更高维度，而在这个维度里我们就能来处理了，举个形象的比喻，就像三维空间里的人不能进行时间跳跃，如果有一个函子能把你映射到四维空间里，那么你就具备任意穿梭时间的能力了。是不是很酷炫？是不是很刺激？对，就是这么魔法！

### 自函子
**自函子是一类比较特殊的函子，它是一种将范畴映射到自身的函子(A functor that maps a category to itself);**   
这是一个很重要概念的，敲黑板，和上面那个单位态射一样，虽然感觉没啥用，但是和0的意义一样重要。

#### 猫
当我们把一个范畴看成一个对象，函子看成箭头，那么我们又得到了一个范畴，这种对象是范畴的范畴，我们叫它Cat（喵~~~），抽象阶梯又往上走了一步，然后我整个人就喵喵喵了不知道该怎么讲了。
但还是要讲啊，我们把Functor当做范畴对象来研究的话，那么在Functor范畴里，从函子F->函子G的态射，我们称之为自然变换（Natural Transformations，一点都不自然），总之都是映射，只是名字变得愈发高大上了而已，总结下就是：

1. 在对象是类型的范畴里，类型间的映射我们叫做态射
2. 在对象是范畴的范畴里，把一个范畴映射到另一个范畴的态射我们叫做函子
3. 在对象是函子的范畴里，把一个函子映射到另一个函子的态射我们叫做自然变换

这种把一个函子映射为另外一个函子的玩意到底怎么跟编程对应起来啊？我们理解的这种映射在编程里一般都表达为函数，那么将一个函数映射为另外一个函数的意思不就是有一个函数接受函数为参数然后返回一个函数么？对，这就是高阶函数，有点道理了，就这么类比理解吧。

### Monad

大菜来了，那什么是Monad？如果考究词源的话，它来自于哲学家G.W.莱布尼兹《单子论》里的概念，单子（Monad）其实是一个很有逼格哲学概念，结合Monad的性质，这确实也是个好名字，但是我们这里不讲这个。

**Monad（单子）是从一类范畴映射到其自身的函子。**  

什么鬼？首先，Monad是一个函子，其次，它是一个特殊的函子，结合上面自函子的定义，我们知道所谓Monad就是一个自函子，当然，除此之外还有一些特殊的约束。

> 一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已，有什么难以理解的。

再次重复这句话，现在多少应该有点感觉了，自函子我们知道了，自函子范畴就是自函子组成的范畴，在这个范畴里，自函子就是范畴的对象，那么态射就是函子到函子之间的映射，称之为自然变换，幺半群就是对这个范畴施加的约束。  

对于一个一个自函子范畴上的对象函子M，如果存在自然变换μ：M(M(x)) -> M(X)、η：x -> M(x)，使得它们保持结合律和单位律，那我们就定义了一个 Monad。注意到μ、η、结合律、单位律形式和幺半群的很相似，所以我们说「自函子范畴上的一个幺半群」。

上码
```javascript
// 在当前上下文中，单位态射，恒等态射指的是同一个意思
// 满足函子的定义
var Monad = function(x) {
  this.__value = x;
}
// 满足Monad自然变换的定义
Monad.of = x => new Monad(x);
// 满足Monad自然变换的定义
Monad.prototype.join = () => this.__value;
Monad.prototype.map = f => Monad.of(f(this.__value));

//  chain :: Monad m => (a -> m b) -> m a -> m b
// 嵌套的Monad经过chain操作合并一层后，依旧返回一个Monad，所以说它是自函子
var chain = curry(function(f, m){
  return m.map(f).join(); 
});

// 定义Monad组合
var mcompose = function(f, g) {
  return compose(chain(f), chain(g));
}
// 定义单位态射
var id = compose(join, of);
// 同一律 (M a)，这玩意的交换图像一个三角形，所以又叫三角同一律
compose(join, of) == compose(join, map(of)) == id

//验证同一律
// 左同一律
mcompose(id, f) == f
// 右同一律
mcompose(f, id) == f
// 验证结合律
mcompose(mcompose(f, g), h) == mcompose(f, mcompose(g, h))

// so，因此Monad函子构成一个范畴
```
![三角同一律](\posts\assets\triangle_identity.png)

这样我们知道函子总是把一个东西从一个范畴映射到另外一个范畴，那么monad函子范畴里有啥特殊的本领么？比如Maybe函子就能做空值检测，那么Monad能做啥？
典型的，Promise就是一个Monad，Prmise().then().then().then().....catch()
其中每一个then都返回一个Promise对象。
monad 让我们深入到嵌套的运算当中，避免回调金字塔，甚至能够作为变量赋值的抽象，以及将异步任务变成有序的同步操作等等，总之这是一个非常厉害的抽象。

最后来说幺半群，在数学中，群表示一个拥有满足封闭性、结合律、有单位元、有逆元的二元运算的代数结构。结合律，单位元我们都知道了，如果仅满足封闭性和结合律，则称G是一个半群（Semigroup），如果仅满足封闭性、结合律并且有幺元，则称G是一个含幺半群（Monoid）。
这么一看，我们终于可以理解那句自函子范畴上的一个幺半群是什么意思了，so，这又什么难以理解的？  

……Monad 确实很难理解，看完《JS 函数式编程指南》我以为我理解了，于是想着写一篇文章来总结，写之前我以为懂了，写的过程中才发现自己不懂，于是又翻遍了知乎上一堆大佬的答案，看了不少文档，写完后才敢说自己确实懂了一点。

将自己的理解表达出来，这是验证自己是否确实懂得某个内容的最好办法，这种表达的形式可以是写博文，也可以是与他人讲述，思维是逐步变深的过程，而表达恰好相反，如果不能表达出来，对于是否真正理解我是持怀疑态度的。某种意义上这也是一个提炼思考的过程。因此学习那些有价值的东西，事后最好用文字总结下来，一方面验证自己的理解，另一方面也能提炼自己的思想，最后是分享，为每一个学习者提供台阶，正如自己在理解过程中能够有这么多资料供自己学习一样，在有足够多的材料下，我想并没有什么是难以学习到的。

最后说说体会，毫无疑问，数学上的东西最好是回归数学上去理解，但是数学总是抽象的，如果没有足够的例子作为形象的支撑，那也是难以理解的。在借住这些例子捕捉到了背后抽象的本质之后。这些例子就像指月的手，我们目的是月亮而不是手，所以光是理解例子并意味着理解了本质，不要让这种对例子的理解给自己一种把握到本质的幻觉。给自己一个最简单的问题？为什么是这些例子？这些例子刻画的东西是什么？正如数学抽象概念往往是由一些公理和性质所刻画，抛开这些不过就是些符号罢了，语言学上有所指和能指的概念，符号是性质的链接，这些是很有意思的观念。